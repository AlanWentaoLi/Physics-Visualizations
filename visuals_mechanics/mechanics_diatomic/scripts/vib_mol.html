<!doctype html>
<head>
    <title>Diatomic Molecule Vibration and Rotation</title>
    <script src = "https://github.com/photonstorm/phaser-ce/releases/download/v2.8.3/phaser.min.js"></script>
    <script src = "./vecops.js"></script>
    <script src = "./potentials.js"></script>
</head>

<div id="physics"></div>
<script>
    /** ============================================ Class Declarations ==============================================*/
    /**
     * Class to describe attributes of atoms that can be used to make up molecules.
     * @param pos: Vector with Cartesian position coordinates
     * @param radius: Radius of atom.
     * @param mass: Mass of atom.
     * @param potential: Object defining potential type at atom (e.g. LJ, harmonic, etc.)
     * @param color: Color of atom for phaser code.(cosmetic only)
     * @constructor: Atom
     */
    Atom = function(pos, radius, mass, potential,color) {
        // Making position and force vectors.
        this.pos = new Vector(pos);                 // Atom position Vector.

        // Checking for unphysical parameters.
        if (radius <= 0 || mass <= 0) {
            console.error("Unphysical system detected! Please check radius, mass and charge values.");

            // Correcting to physical values.
            radius = -radius;
            mass = -mass;
        }
        this.color = color;
        this.r = radius;                            // Atom radius.
        this.m = mass;                              // Atom mass.
        this.sprite = addAtom(this);
        this.V = potential;                          // Setting potential centre of atom.
    };

    /**
     * Class to make molecule out of atoms, with a spring constant that defines strength of bonds, and instantiated with
     * rotational and vibrational E.
     * @param atoms: Array containing all atoms in molecules.
     * @param vibrational_E: Vibrational kinetic energy.
     * @param rotational_E: Rotational kinetic energy.
     * @constructor
     */
    Molecule = function(atoms, vibrational_E, rotational_E) {

        // Checking objects of class Atom passed in in the list.
        if (atoms.constructor === Array || atoms[0].constructor === Atom)
        {
            this.atoms = atoms;                                                             // Atoms.

            // Calculating scalar distance between atoms.
            this.r = new Vector(this.atoms[0].pos.subtract(this.atoms[1].pos)).mag();      // Atom separation.

            this.COM = this.calcCOM();                                      // Centre of mass initialised as 0 vector.
        }
        this.elasped = 0;
        this.I = this.calcMoI();                                            // Moment of inertia initialised as 0.
        this.E_v = vibrational_E;                                           // Vibrational energy.
        this.E_r = rotational_E;                                            // Rotational energy.
        this.PE = this.calcPE();                                             // Potential energy.
        this.Lsq = 2 * rotational_E*this.I;
        this.reducedM = this.calcMu();
    };


    /** =============================================== Class Methods ================================================*/
    /**
     * Calculates the scalar distance between a pair of atoms.
     * @param atom1: Atom
     * @param atom2: Another atom
     * @returns {number} separation, r.
     */
    Molecule.prototype.calcSeparation = function(atom1, atom2) {
        var r = atom1.pos.subtract(atom2.pos);
        return new Vector(r).mag();
    };

    /**
     * Calculates the unit vector between two atom positions.
     * @param atom1: Atom
     * @param atom2: Another atom
     * @returns {Vector} Unit vector
     */
    Molecule.prototype.calcUnitVect = function(atom1, atom2) {
        var r = atom1.pos.subtract(atom2.pos);
        return new Vector(r).unit();
    };

    /**
     * Calculates the potential energy of the system using the potential functions instantiated to each atom.
     * @returns {Number} System PE.
     */
    Molecule.prototype.calcPE = function() {
        var pot_energy = 0;                                                         // Potential energy.

        // Pairwise potential calculation.
        for (var i = 0; i < this.atoms.length; i++) {
            for (var j = 0; j < this.atoms.length; j++) {
                // Avoiding calculating potential between the same atom (r = 0, V --> inf)
                if (i !== j) {
                    var r = this.calcSeparation(this.atoms[i], this.atoms[j]);      // Scalar distance between atoms.
                    pot_energy += this.atoms[i].V.calcV(rs);                         // Calculating potential energy.
                }
            }
        }
        this.PE = pot_energy;
        return this.PE;
    };
    /**
     * @returns {Number} Current value of the rotational kinetic energy of the system.
     *
     */
    Molecule.prototype.calcRotKE = function() {
        // TODO: Implement function to calculate KE
        return this.Lsq/(2*this.I);


    };
    /**
     * Calculates reduced mass of the system (for arbitrary number of atoms)
     *  @returns {Number} value of the reduced mass of the system
     *
     */
    Molecule.prototype.calcMu = function () {
        var muInv = 0;
        for(var i = 0; i < this.atoms.length;i++){
           muInv += 1/this.atoms.m;
        }
        return 1/muInv;
    };
    /**
     * Updates coordinates of atoms after rotation about COM.
     * @param t: Timestep
     * @returns {Array} List of atoms in molecule after rotation around COM.
     */
    Molecule.prototype.calcRotCoords = function(t) {
        // E_r = 0.5 * I * w ** 2
        var w = Math.sqrt(2 * this.E_r / this.I);                                           // Angular velocity, w
        var d_Angle = w * t;                                                       // Rotation angle around COM (radians)

        // Rotation of atoms about COM.
        for (var i = 0; i < this.atoms.length; i++)
        {
            this.atoms[i].pos = this.atoms[i].pos.subtract(this.COM);            // Find atom coords with COM at Origin
            this.atoms[i].pos = new Vector(this.atoms[i].pos.rotate(d_Angle));     // Updating atoms coords after rotation
            this.atoms[i].pos = this.atoms[i].pos.add(this.COM);                 // Moving COM back to original coords
        }

        return this.atoms
    };

    /**
     * Calculates Moment of Inertia.
     * @returns {number} I
     */
    Molecule.prototype.calcMoI = function() {
        var I = 0;                                                          // Moment of Inertia.
        for (var i = 0; i < this.atoms.length; i++) {                       // Distance between this atom and COM.
            var r_i = new Vector(this.atoms[i].pos.subtract(this.COM));     // Distance between this atom and COM
            I += this.atoms[i].m * Math.pow(r_i.mag(), 2);                  // m*r**2 contribution for this atom.
            console.log(I);
        }
        return I                                                            // Return Moment of Inertia (scalar).
    };

    /**
     * Calculates Centre of Mass coordinates.
     * @returns {Vector} Centre of Mass
     */
    Molecule.prototype.calcCOM = function() {
        var total_m = 0;                                                    // Total mass of system.

        var total_mx = [];                                                  // Total mass * position (mx) of system.
        for (var j = 0; j < this.atoms[0].pos.items.length; j++) {
            total_mx.push(0)
        }
        total_mx = new Vector(total_mx);                                    // mx initialised as 0 vector.

        // Summing mx and m.
        for (var i = 0; i < this.atoms.length; i++) {
            total_m += this.atoms[i].m;
            var mx = new Vector(this.atoms[i].pos.multiply(this.atoms[i].m));
            total_mx = new Vector(total_mx.add(mx));
        }

        this.COM = new Vector(total_mx.multiply(1 / total_m));              // Updating instance COM coords.

        return new Vector(total_mx.multiply(1 / total_m));                  // Return Vector coordinates of COM.
    };
    /**
     * @param elapsed: time that the molecule has been alive for
     * @param deltaTime: time passed between this frame and last frame important for incrementing physics.
     */

    Molecule.prototype.calculateDisplacement = function(deltaTime,elapsed){
        var amplitude = Math.sqrt(2*this.E_v/kval);
        var natFreq = Math.sqrt(kVal / this.reducedM);
        var dx = -1 * amplitude * Math.sin(natFreq*elapsed) * deltaTime;
        //get seperation vector and subtract dx*unitvector in direction of sep vector to create oscillation.
        var r_i_new = calcSeperation() - calcUnitVector() * dx;

    };
    /**
     * Function that performs physics calculation at a fixed rate (usually 60FPS), in here the relevant values
     * for the next frame should be calculated.
     * @param deltaTime : time passed between this frame and the last frame for incrementing physics.
     */
    Molecule.prototype.update = function(deltaTime) {
        this.elasped += deltaTime;
        calcRotCoords(deltaTime,elapsed);
        //TODO: Calculate the vibration amplitude given the vibrational KE
        //TODO: Update position due to vibrational motion.
        //TODO: Update position due to rotational motion.
        //TODO: Check if vibrational energy greater than restoring energy (Hooke's Law)

    };
</script>

<div id="phaser"></div>
<script src="./graphics.js"></script>
<body>

</body>