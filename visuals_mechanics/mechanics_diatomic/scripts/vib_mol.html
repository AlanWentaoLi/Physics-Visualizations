<!doctype html>
<head>
    <title>Diatomic Molecule Vibration and Rotation</title>
    <script src = "./vecops.js"></script>
    <script src = "./potentials.js"></script>
</head>

<div id="physics"></div>
<script>
    /** ============================================ Class Declarations ==============================================*/
    /**
     * Class to describe attributes of atoms that can be used to make up molecules.
     * @param pos: Vector with Cartesian position coordinates
     * @param radius: Radius of atom.
     * @param mass: Mass of atom.
     * @param potential: Object defining potential type at atom (e.g. LJ, harmonic, etc.)
     * @constructor: Atom
     */
    Atom = function(pos, radius, mass, potential) {
        // Making position and force vectors.
        this.pos = new Vector(pos);                 // Atom position Vector.

        // Checking for unphysical parameters.
        if (radius <= 0 || mass <= 0) {
            console.error("Unphysical system detected! Please check radius, mass and charge values.");

            // Correcting to physical values.
            radius = -radius;
            mass = -mass;
        }

        this.r = radius;                            // Atom radius.
        this.m = mass;                              // Atom mass.

        this.V = potential                          // Setting potential centre of atom.
    };

    /**
     * Class to make molecule out of atoms, with a spring constant that defines strength of bonds, and instantiated with
     * rotational and vibrational E.
     * @param atoms: Array containing all atoms in molecules.
     * @param vibrational_E: Vibrational kinetic energy.
     * @param rotational_E: Rotational kinetic energy.
     * @constructor
     */
    Molecule = function(atoms, vibrational_E, rotational_E) {

        // Checking objects of class Atom passed in in the list.
        if (atoms.constructor === Array || atoms[0].constructor === Atom)
        {
            this.atoms = atoms;                                                             // Atoms.

            // Calculating scalar distance between atoms.
            this.r = new Vector(this.atoms[0].pos.subtract(this.atoms[1].pos)).norm();      // Atom separation.

            this.COM = this.calcCOM();                                      // Centre of mass initialised as 0 vector.
        }

        this.I = this.calcMoI();                                            // Moment of inertia initialised as 0.
        this.E_v = vibrational_E;                                           // Vibrational energy.
        this.E_r = rotational_E;                                            // Rotational energy.
        this.PE = this.calcPE()                                             // Potential energy.
    };

    /** =============================================== Class Methods ================================================*/
    /**
     * Calculates the scalar distance between a pair of atoms.
     * @param atom1: Atom
     * @param atom2: Another atom
     * @returns {number} separation, r.
     */
    Molecule.prototype.calcSeparation = function(atom1, atom2) {
        var r = atom1.pos.subtract(atom2.pos);
        return new Vector(r).norm()
    };

    /**
     * Calculates the unit vector between two atom positions.
     * @param atom1: Atom
     * @param atom2: Another atom
     * @returns {Vector} Unit vector
     */
    Molecule.prototype.calcUnitVect = function(atom1, atom2) {
        var r = atom1.pos.subtract(atom2.pos);
        return new Vector(r).unit()
    };

    /**
     * Calculates the potential energy of the system using the potential functions instantiated to each atom.
     * @returns {Number} System PE.
     */
    Molecule.prototype.calcPE = function() {
        var pot_energy = 0;                                                         // Potential energy.

        // Pairwise potential calculation.
        for (var i = 0; i < this.atoms.length; i++) {
            for (var j = 0; j < this.atoms.length; j++) {

                // Avoiding calculating potential between the same atom (r = 0, V --> inf)
                if (i !== j) {
                    var r = this.calcSeparation(this.atoms[i], this.atoms[j]);      // Scalar distance between atoms.
                    pot_energy += this.atoms[i].V.calcV(r);                         // Calculating potential energy.
                }
            }
        }
        this.PE = pot_energy;
        return this.PE;
    };

    Molecule.prototype.calcRotKE = function() {
        // TODO: Implement function to calculate KE
    };

    /**
     * Updates coordinates of atoms after rotation about COM.
     * @param t: Timestep
     * @returns {Array} List of atoms in molecule after rotation around COM.
     */
    Molecule.prototype.calcRotCoords = function(t) {
        // E_r = 0.5 * I * w ** 2
        var w = 2 * this.E_r / this.I;                                           // Angular velocity, w
        var angle = w * t;                                                       // Rotation angle around COM (radians)

        // Rotation of atoms about COM.
        for (var i = 0; i < this.atoms.length; i++)
        {
            this.atoms[i].pos = this.atoms[i].pos.subtract(this.COM);            // Find atom coords with COM at Origin
            this.atoms[i].pos = new Vector(this.atoms[i].pos.rotate(angle));     // Updating atoms coords after rotation
            this.atoms[i].pos = this.atoms[i].pos.add(this.COM);                 // Moving COM back to original coords
        }

        return this.atoms
    };

    /**
     * Calculates Moment of Inertia.
     * @returns {number} I
     */
    Molecule.prototype.calcMoI = function() {
        var I = 0;                                                          // Moment of Inertia.
        for (var i = 0; i < this.atoms.length; i++) {
            var r_i = new Vector(this.atoms[i].pos.subtract(this.COM));     // Distance between this atom and COM.
            I += this.atoms[i].m * Math.pow(r_i.norm(), 2);                 // m*r**2 contribution for this atom.
            alert(I);
        }
        return I                                                            // Return Moment of Inertia (scalar).
    };

    /**
     * Calculates Centre of Mass coordinates.
     * @returns {Vector} Centre of Mass
     */
    Molecule.prototype.calcCOM = function() {
        var total_m = 0;                                                    // Total mass of system.

        var total_mx = [];                                                  // Total mass * position (mx) of system.
        for (var j = 0; j < this.atoms[0].pos.items.length; j++) {
            total_mx.push(0)
        }
        total_mx = new Vector(total_mx);                                    // mx initialised as 0 vector.

        // Summing mx and m.
        for (var i = 0; i < this.atoms.length; i++) {
            total_m += this.atoms[i].m;
            var mx = new Vector(this.atoms[i].pos.multiply(this.atoms[i].m));
            total_mx = new Vector(total_mx.add(mx));
        }

        this.COM = new Vector(total_mx.multiply(1 / total_m));              // Updating instance COM coords.

        return new Vector(total_mx.multiply(1 / total_m));                  // Return Vector coordinates of COM.
    };

    Molecule.prototype.update = function() {
        //TODO: Calculate rotation angle given the rotational KE
        //TODO: Calculate the vibration amplitude given the vibrational KE
        //TODO: Update position due to vibrational motion.
        //TODO: Update position due to rotational motion.
        //TODO: Check if vibrational energy greater than restoring energy (Hooke's Law)
    };
</script>

<div id="phaser"></div>
<script>
    potential = new LJ(2, 4);
    a1 = new Atom([0, 0], 2, 1, potential);
    a2 = new Atom([3, 4], 1, 1, potential);
    mol1 = new Molecule([a1, a2], 2, 2);

    alert(" COM is " + mol1.COM.items);
    alert(" I is " + mol1.I);
</script>

<body>

</body>